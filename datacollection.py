# -*- coding: utf-8 -*-
"""DataCollection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pSoiVaG_B1eGr2gDc7PhUZCHqTmHoZTj
"""
from flask import Flask, request, jsonify
import networkx as nx
import osmnx as ox
import numpy as np

app = Flask(__name__)

ox.config(use_cache=True, log_console=True)

G = ox.graph_from_place("Fullerton,California,USA", network_type='all')

# Create a mapping from node IDs to smaller integer indices
node_mapping = {node: index for index, node in enumerate(G.nodes)}

# Create a reverse mapping from integer indices to node IDs
reverse_mapping = {index: node for node, index in node_mapping.items()}

# Create an empty distance matrix
num_nodes = len(G.nodes)
distance_matrix = np.full((num_nodes, num_nodes), np.inf)

# Add speed and travel time information to the graph
G = ox.speed.add_edge_speeds(G)
G = ox.speed.add_edge_travel_times(G)

# Convert the graph to GeoDataFrames
nodes, edges = ox.graph_to_gdfs(G)

# Define your source and destination points (latitude and longitude)
source_point = (33.8781, -117.87957)
destination_point = (33.87827, -117.87968)

# Download the street network graph for the specified area
graph = ox.graph_from_point(source_point, dist=150, network_type='all')

# Find the nearest network nodes to the source and destination points
source_node = ox.distance.nearest_nodes(graph, source_point[1], source_point[0])
destination_node = ox.distance.nearest_nodes(graph, destination_point[1], destination_point[0])

all_paths = list(nx.all_simple_paths(graph, source=source_node, target=destination_node, cutoff=20))

# Fill in the distance matrix with actual distances between nodes
for path in all_paths:
    for i in range(len(path) - 1):
        node1, node2 = path[i], path[i + 1]
        if node1 in node_mapping and node2 in node_mapping:
            edge_data = graph.get_edge_data(node1, node2, 0)
            if edge_data:
                distance = edge_data['length']
                distance_matrix[node_mapping[node1]][node_mapping[node2]] = distance
                distance_matrix[node_mapping[node2]][node_mapping[node1]] = distance

# Print or use the distance matrix as needed
print(distance_matrix)

# If you want to convert the indices back to node IDs:
# node_id = reverse_mapping[index]

@app.route('/distance_matrix', methods=['GET'])
def get_distance_matrix():
    try:
        # Here, you can return the distance matrix as a JSON response
        return jsonify(distance_matrix.tolist())
    except Exception as e:
        return jsonify({'error': str(e)})


if __name__ == '__main__':
    app.run(debug=True)
